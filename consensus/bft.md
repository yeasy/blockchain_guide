## 拜占庭问题与算法

### 拜占庭问题

又叫拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），可能会干扰一致性的达成。

对于拜占庭问题来说，假如节点总数为 N，叛变将军数为 F，则当 $$ N \ge 3F+1 $$ 时，问题才有解，即 Byzantine Fault Tolerant (BFT) 算法。

### 中国将军问题
类似的，中国将军问题：两个将军要通过信使来达成进攻还是撤退的约定，但信使可能迷路或被敌军阻拦（通信可能故障），如何达成一致。根据 FLP 不可能原理，这个问题无解。


### BFT 算法
面向拜占庭问题的算法，解决的是网络通信可靠，但节点可能故障情况下的一致性达成。

最早由 Castro 和 Liskov 在 1999 年提出的 PBFT 是第一个得到广泛应用的 BFT 算法。只要系统中有 2/3 的节点是正常工作的，则可以保证一致性。

### Paxos

1990 年由 Leslie Lamport 提出的 [Paxos](http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf) 一致性算法，在工程角度实现了一种最大化保障一致性（极小的概率无法实现一致性）的机制。

Paxos 是第一个被证明的一致性算法，其原理是现在一致性算法设计的鼻祖，然而以复杂难懂出名。

Paxos 被应用在 Chubby、ZooKeeper 这样的系统中。

### Raft
[Raft](https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf) 算法是Paxos 算法的一种简化实现。

包括三种角色：leader、candiate 和 follower，其基本过程为：

* Leader 选举：每个 candidate 随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为 leader；
* 同步 log：leader 会找到系统中 log 最新的记录，并强制所有的 follower 来刷新到这个记录；

*注：此处 log 并非是指日志消息，而是各种事件的发生记录。*

### 新的解决思路
拜占庭问题之所以难解，在于任何时候系统中都可能存在多个提案（提案成本为 0），并且要完成最终的一致性确认过程十分困难，容易受干扰。但是一旦确认，即为最终确认。

比特币的区块链网络在设计时提出了创新的 PoW（Proof of Work） 算法思路。一个是限制一段时间内整个网络中出现提案的个数，另外一个是放宽对最终一致性确认的需求，约定好大家都确认并沿着已知最长的链进行拓宽。系统的最终确认是概率意义上的存在。这样，即便有人试图恶意破坏，也会付出很大的经济代价（付出超过系统一半的算力）。

后来的各种 PoX 系列算法，也都是沿着这个思路进行改进，采用经济上的惩罚来制约攻击者。